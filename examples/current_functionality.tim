println("basic print functionality")
println(1100 + 150 * 2 + 37 - 100)
println(1 * 2 + 3 / (4 + true))
println(1 + 1 - 1)

println("\nvariables and printing of variables")
u16 bla
println(bla)  // TODO: fix that I'm not 0 (initial value of type)
u16 bla2 = 1337
println(bla2)
u8 value = 0
value = 1
print("value of value after assignment: {value}")

println("\ntesting types")
u1 _u1 = 1
u8 _u8 = 12
u16 _u16 = 1234
u32 _u32 = 123456
u64 _u64 = 12345678
s8 _s8 = -12
s16 _s16 = -1234
s32 _s32 = 123456
s64 _s64 = -12345678
f32 _f32 = -12345678
f64 _f64 = -12345678

println("\nprinting types")
println(_u1)
println(_u8)
println(_u16)
println(_u32)
println(_u64)
println(_s8)
println(_s16)
println(_s32)
println(_s64)
println(_f32)
println(_f64)

println("\nboolean expressions")
println(1 == 1)
println(1 == 2)
println(2 > 1)
println(1 > 2)
println(2 >= 1)
println(1 >= 1)
println(1 >= 2)
println(1 < 2)
println(2 < 1)
println(1 <= 2)
println(1 <= 1)
println(2 <= 1)
println(1337 != 1338)
println(1337 != 1337)

println("\nparse an if-statement")
if 1337:
    println(1337)
else if 1338:
    println(1338)
else:
    println(0)

println("\ntesting pre and post increment/decrement")
u8 index = 0
println(index++)
println(index++)
u8 other_index = 0
println(++other_index)
println(--other_index)

println("\nparsing a for-loop statement")
for u8 i = 0; i < 10; i++:
    i++
    println(i)
println("also test printing everything on a single line")
for u8 i = 0; i < 10; i++:
    print(i)
println("")  // TODO: fix that I need an empty string here :D
println("and parsing a while-loop statement")
u8 idx = 0
while idx++ < 10:
    idx++
    println(idx)

println("\nparsing function statements")
u8 func1(u8 argument):
    println(argument)
    u8 local = 1
    local++
    println(local)
    return argument + local
u8 func2():  // u8 as we don't support pointers (yet) :s
    println(1337)
    return null
void func3(u8 a, u8 b, u8 c):
    println(a + b + c)
    return
println("and call the functions")
println("func1:")
u8 ret1 = func1(10)
println("return1: {ret1}")
println("func2:")
u8 ret2 = func2()
println("return2: {ret2}")
println("func3:")
func3(1, 2, 3)
println("func3 returns void")

println("\ntype-cast a value around")
u8 small = 123
println(small)
u16 big = (u16)small + 1337 // this is gonna be big
println(big)
u8 small_again = (u8)big // this is not able to hold the big number
println(small_again)

println("\ndo we support 0xe stuff??")
println("println(0xe+1): {0xe+1}")
println("yes we do!")

// example classes

class ExampleClass:
    // first we define the variables that the class contain (like entries of a struct)
    u32 variable1
    u8 variable2
    bool _is_true

    // then we have functions of the class (and constructor/destructor if present)

    ExampleClass(u32 constructor_value):
        // initialization happens here, the constructor (if it is present)
        u8 iets = 0
        this.variable1 = constructor_value
        iets = 1
        iets = 2
        this.variable2 = 10
        this._is_true = false

    ~ExampleClass():
        // destruction can happen here

    u32 get_value():
        u32 offset = 5
        return this.variable1 + (u32)this.variable2 + offset

    bool is_true():
        return this._is_true

    u32 result():
        if this.is_true():
            return this.get_value()
        else:
            return 0

    u32 add(u32 value):
        return this.get_value() + value

ExampleClass instance
println("result(): {instance.result()}")
println("add(1337): {instance.add(1337)}")

/*
// single class function
ExampleClass instance;
instance.func()
-> ExampleClass_func(&instance);

// multiple class function
class C1 {
    void func() {
        //
    }
}

class C2 {
    C1 c1;
    C2(C1 c1) {
        this.c1 = c1;
    }
}

C1 c1;
C2 c2 = C2(c1)
c2.c1.func()
-> C1_func(&c2.c1);
*/

println("example usage of 'list' collection")

println("create an instance of a list, which has a size of 0")
list[u32] some_list

println("some functions to be called on the list")
println("\nreturns the size, should be initialized as 0: {some_list.size()}")
some_list.add(1337)
println("\nadds an element, 1, to the list, size: {some_list.size()}")
println("\ngets the 0th element (or 0/crash when not there): {some_list.get(0)}")
println("\nremoves the 0th element, return true on success, false/crash on failure: {some_list.del(0)}")
println("\ninserts 10 at location 0, return true on success, false/crash on failure: {some_list.insert(0, 10)}")
println("\nsize of the list now: {some_list.size()}")
println("\ngets the 0th element (or 0/crash when not there) {some_list.get(0)}")
list[f64] doublee
list[u1] boool
list[s8] charr
charr.add(0)
charr.add(1)
println(charr.size())
println(charr.get(0))
println(charr.get(1))
println("value of charr.get(1): {charr.get(1)}, woohoo")

// example program using buitin variables

u32 variable = 1337
println("\nvalue of variable is: {variable}")

s32 negative_variable = -1 * 1337
println("the negative value is: {negative_variable}")

println("calculation can be done in a string! 1 + 1 = {1 + 1}")

println("\nwe also support characters, like char c = 'c'")
char c = 'c'
println("the character is printed as: {c} (with numeric value: {(u8)c})")

print("basic print functionality")
print(1100 + 150 * 2 + 37 - 100)
print(1 * 2 + 3 / (4 + true))
print(1 + 1 - 1)

print("\nvariables and printing of variables")
u16 bla
print(bla)
u16 bla2 = 1337
print(bla2)

print("\ntesting types")
u1 _u1 = 1
u8 _u8 = 12
u16 _u16 = 1234
u32 _u32 = 123456
u64 _u64 = 12345678
s8 _s8 = -12
s16 _s16 = -1234
s32 _s32 = 123456
s64 _s64 = -12345678
f32 _f32 = -12345678
f64 _f64 = -12345678

print("\nprinting types")
print(_u1)
print(_u8)
print(_u16)
print(_u32)
print(_u64)
print(_s8)
print(_s16)
print(_s32)
print(_s64)
print(_f32)
print(_f64)

print("\nboolean expressions")
print(1 == 1)
print(1 == 2)
print(2 > 1)
print(1 > 2)
print(2 >= 1)
print(1 >= 1)
print(1 >= 2)
print(1 < 2)
print(2 < 1)
print(1 <= 2)
print(1 <= 1)
print(2 <= 1)
print(1337 != 1338)
print(1337 != 1337)

print("\nparse an if-statement")
if 1337:
    print(1337)
else if 1338:
    print(1338)
else:
    print(0)

print("\ntesting pre and post increment/decrement")
u8 index = 0
print(index++)
print(index++)
u8 other_index = 0
print(++other_index)
print(--other_index)

print("\nparsing a for-loop statement")
for u8 i = 0; i < 10; i++:
    i++
    print(i)
print("and parsing a while-loop statement")
u8 idx = 0
while idx++ < 10:
    idx++
    print(idx)

print("\nparsing function statements")
u8 func1(u8 argument):
    print(argument)
    u8 local = 1
    local++
    print(local)
    return argument + local
u8 func2():  // u8 as we don't support pointers (yet) :s
    print(1337)
    return null
void func3(u8 a, u8 b, u8 c):
    print(a + b + c)
    return
print("and call the functions")
print("func1:")
u8 ret1 = func1(10)
print("return1: {ret1}")
print("func2:")
u8 ret2 = func2()
print("return2: {ret2}")
print("func3:")
func3(1, 2, 3)
print("func3 returns void")

print("\ntype-cast a value around")
u8 small = 123
print(small)
u16 big = (u16)small + 1337 // this is gonna be big
print(big)
u8 small_again = (u8)big // this is not able to hold the big number
print(small_again)

print("\ndo we support 0xe stuff??")
print("print(0xe+1): {0xe+1}")
print("yes we do!")

// example classes

class ExampleClass:
    // first we define the variables that the class contain (like entries of a struct)
    u32 variable1
    u8 variable2
    bool is_true

    // then we have functions of the class (and constructor/destructor if present)

    ExampleClass(u32 constructor_value):
        // initialization happens here, the constructor (if it is present)
        u8 iets = 0
        this.variable1 = constructor_value
        iets = 1
        iets = 2
        this.variable2 = 10
        this.is_true = false

    ~ExampleClass():
        // destruction can happen here

    u32 get_value():
        u32 offset = 5
        return this.variable1 + this.variable2 + offset

    bool is_true():
        return this.is_true

    u32 result():
        if this.is_true():
            return this.get_value()
        else:
            return 0

    u32 add(u32 value):
        return this.get_value() + value

ExampleClass instance
print("result(): {instance.result()}")
print("add(1337): {instance.add(1337)}")

/*
// single class function
ExampleClass instance;
instance.func()
-> ExampleClass_func(&instance);

// multiple class function
class C1 {
    void func() {
        //
    }
}

class C2 {
    C1 c1;
    C2(C1 c1) {
        this.c1 = c1;
    }
}

C1 c1;
C2 c2 = C2(c1)
c2.c1.func()
-> C1_func(&c2.c1);
*/

print("example usage of 'list' collection")

print("create an instance of a list, which has a size of 0")
list[u32] some_list

print("some functions to be called on the list")
print("\nreturns the size, should be initialized as 0: {some_list.size()}")
some_list.add(1337)
print("\nadds an element, 1, to the list, size: {some_list.size()}")
print("\ngets the 0th element (or 0/crash when not there): {some_list.get(0)}")
print("\nremoves the 0th element, return true on success, false/crash on failure: {some_list.del(0)}")
print("\ninserts 10 at location 0, return true on success, false/crash on failure: {some_list.insert(0, 10)}")
print("\nsize of the list now: {some_list.size()}")
print("\ngets the 0th element (or 0/crash when not there) {some_list.get(0)}")
list[f64] doublee
list[u1] boool
list[s8] charr
charr.add(0)
charr.add(1)
print(charr.size())
print(charr.get(0))
print(charr.get(1))
print("value of charr.get(1): {charr.get(1)}, woohoo")

// example program using buitin variables

u32 variable = 1337
print("\nvalue of variable is: {variable}")

s32 negative_variable = -1 * 1337
print("the negative value is: {negative_variable}")

print("calculation can be done in a string! 1 + 1 = {1 + 1}")
